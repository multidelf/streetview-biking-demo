<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>ä¸€é¨å‡ºç™¼å§ï½œè¡—æ™¯æ¨¡æ“¬èˆ‡å¡åº¦æŠ˜ç·šåœ–</title>
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; overflow: hidden;
      font-family: sans-serif;
    }
    #map, #pano {
      width: 100vw; height: 100vh;
    }
    #map {
      display: block;
    }
    #pano, #miniMap {
      display: none;
    }
    #controlPanel {
      position: absolute; top: 60px; left: 10px; z-index: 10;
      background: rgba(255,255,255,0.95); padding: 12px; width: 380px;
      border-left: 5px solid #4CAF50; border-radius: 5px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    select, textarea, input[type=text], button {
      width: 100%; margin-top: 6px; padding: 6px; font-size: 14px;
      border: 1px solid #ccc; border-radius: 4px;
    }
    .mode-block {
      display: none; margin-top: 10px;
    }
    .checkbox-row {
      display: flex; align-items: center; margin-bottom: 4px;
    }
    .checkbox-row input[type=checkbox] {
      margin-right: 8px;
    }
    #miniMap {
      position: absolute; bottom: 10px; right: 10px;
      width: 400px; height: 200px; border: 2px solid #888; z-index: 12;
    }
    #elevationChart {
      margin-top: 10px; width: 100%; height: 150px;
    }
  </style>
</head>
<body>
  <div id="controlPanel">
    <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
      <img src="logo.jpg" alt="Logo" style="width:32px; height:32px;" />
      <span style="font-size:18px; font-weight:bold;">ä¸€é¨å‡ºç™¼å§ï½œè¡—æ™¯é¨ä¹˜æ¨¡æ“¬å™¨V9.2</span>
    </div>
    <div style="background:rgba(255,255,255,0.9); padding:8px; border:1px solid #ccc; border-radius:4px; font-size:13px;">
      <strong>æ“ä½œç°¡ä»‹ï¼š</strong><br />
      - ğŸ”½ è·¯ç·šä¸‹æ‹‰é¸å–®ï¼šå¾é è¨­è·¯ç·šä¸­é¸æ“‡ä¸¦å¤šé¸ç«™é»<br />
      - ğŸ“ è²¼ä¸Šç¶“ç·¯åº¦ï¼šè‡ªè¨‚åº§æ¨™ä¸¦ç¹ªè£½ç«™é»<br />
      - ğŸ“ A â†’ B æœå°‹ï¼šè¼¸å…¥åœ°å€è‡ªå‹•å°‹æ‰¾é»<br /><br />
      - ä»¥ä¸Šä»»é¸ä¸€é …å®Œæˆå¾Œï¼Œé»é¸"åˆ‡æ›è¡—æ™¯"é–‹å§‹æ¨¡æ“¬é¨ä¹˜<br /><br />
      - W / â†‘ï¼šå‰é€²ä¸€æ®µè·é›¢<br />
      - S / â†“ï¼šå¾Œé€€ä¸€æ®µè·é›¢<br />
      - A / Dï¼šå·¦å³æ—‹è½‰è¦–è§’<br />
      - æ»‘é¼ æ‹–æ›³ï¼šæ—‹è½‰è¡—æ™¯è¦–è§’<br />
      - è¡—æ™¯å°èˆªåƒ…å¯ä¾ç…§è¦åŠƒè·¯ç·šå‰é€²
    </div>
    <label>ğŸ“Œ é¸æ“‡è¼¸å…¥æ¨¡å¼</label>
    <select id="modeSelect">
      <option value="sheet">ğŸ”½ è·¯ç·šä¸‹æ‹‰é¸å–®</option>
      <option value="paste">ğŸ“ è²¼ä¸Šç¶“ç·¯åº¦</option>
      <option value="ab">ğŸ“ A â†’ B æœå°‹</option>
    </select>
    <div class="mode-block" id="sheetBlock">
      <select id="routeSelect"><option>è«‹é¸æ“‡è·¯ç·š</option></select>
      <div style="display:flex; gap:10px;">
        <button onclick="selectAll()">å…¨é¸</button>
        <button onclick="clearAll()">å–æ¶ˆå…¨é¸</button>
      </div>
      <div id="pointList" style="max-height:200px; overflow:auto;"></div>
      <button id="planPolylineBtn">è¦åŠƒè·¯ç·š</button>
    </div>
    <div class="mode-block" id="pasteBlock">
      <textarea id="coordTextarea" rows="4" placeholder="è²¼ä¸Šç¶“ç·¯åº¦ï¼Œå¦‚ï¼š24.1612666,120.6951848"></textarea>
      <button onclick="drawFromPasted()">ç¹ªè£½æ¨™è¨˜</button>
    </div>
    <div class="mode-block" id="abBlock">
      <input id="pointA" placeholder="èµ·é»åœ°åæˆ–åœ°å€" />
      <input id="pointB" placeholder="çµ‚é»åœ°åæˆ–åœ°å€" />
      <button id="searchBtn" onclick="drawFromAB()" disabled>æœå°‹è·¯ç·šæ¨™è¨˜</button>
    </div>
    <div style="margin-top:10px;">
      <button id="toggleViewBtn" onclick="toggleView()" style="display:none;">åˆ‡æ›è¡—æ™¯/åœ°åœ–</button>
      <button id="autoPlayBtn" onclick="startAutoPlay()" style="display:none; margin-top:6px;">é–‹å§‹è‡ªå‹•å°èˆª</button>
    </div>
    <canvas id="elevationChart"></canvas>
  </div>

  <div id="map"></div>
  <div id="pano"></div>
  <div id="miniMap"></div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB3MsVlR7h6MsYf1Xjw02BPwB3r95wXsYk&libraries=places,geometry&callback=initMap"></script>
  <script>
    const apiBase = "https://script.google.com/macros/s/AKfycbzctNoMZS3m3FX3q1s3Ka4ZgK-bVsMKkOh0rL9IQaS1wO1dprzkUcCpZqE4YpQW7vtA/exec";
    let map, panorama, miniMap, miniMarker, miniPolyline, infoWindow;
    let markers = [], stationData = [], stationMarkersMini = [], polyline, polylinePath = [];
    let currentMode = 'map', stepIndex = 0, autoPlayTimer = null;
    const RESAMPLE_INTERVAL = 20; // å…¬å°º
    let miniMapMarkers = [];

    // å¡åº¦åœ–ç›¸é—œ
    let elevationChart = null;
    let elevationData = [];
    let elevationLabels = [];
    let elevationCursorIndex = -1;

    function initMap() {
      map = new google.maps.Map(document.getElementById('map'), { center:{lat:24.15,lng:120.68}, zoom:13 });
      panorama = new google.maps.StreetViewPanorama(document.getElementById('pano'), {
        position:{lat:24.15,lng:120.68}, pov:{heading:0,pitch:0}, visible:false,
        motionTracking:false, motionTrackingControl:false
      });
      map.setStreetView(panorama);
      miniMap = new google.maps.Map(document.getElementById('miniMap'), { center:{lat:24.15,lng:120.68}, zoom:16, disableDefaultUI:true });
      miniMarker = new google.maps.Marker({ map:miniMap, position:{lat:24.15,lng:120.68}, icon:{ path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW, scale:5, rotation:0 } });
      miniPolyline = new google.maps.Polyline({ map:miniMap, path:[], strokeColor:'#FF5722', strokeWeight:3 });
      infoWindow = new google.maps.InfoWindow();

      setupAutocomplete();
      fetchRouteNames();
      document.getElementById('sheetBlock').style.display = 'block';
      document.getElementById('modeSelect').addEventListener('change', e => {
        document.querySelectorAll('.mode-block').forEach(b => b.style.display='none');
        document.getElementById(e.target.value + 'Block').style.display='block';
      });
      document.getElementById('planPolylineBtn').addEventListener('click', planPolyline);
      window.addEventListener('keydown', handleKey);

      document.getElementById('autoPlayBtn').style.display = 'none';
    }
    window.initMap = initMap;

    function setupAutocomplete() {
      const autoA = new google.maps.places.Autocomplete(document.getElementById('pointA'));
      const autoB = new google.maps.places.Autocomplete(document.getElementById('pointB'));
      autoA.addListener('place_changed', () => {
        const p = autoA.getPlace(); if(!p.geometry) return;
        if(markers.A) markers.A.setMap(null);
        markers.A = new google.maps.Marker({ map, position: p.geometry.location });
        infoWindow.setContent('èµ·é»ï¼š' + p.name);
        infoWindow.open(map, markers.A);
        map.setCenter(p.geometry.location);
        toggleSearchBtn();
      });
      autoB.addListener('place_changed', () => {
        const p = autoB.getPlace(); if(!p.geometry) return;
        if(markers.B) markers.B.setMap(null);
        markers.B = new google.maps.Marker({ map, position: p.geometry.location });
        infoWindow.setContent('çµ‚é»ï¼š' + p.name);
        infoWindow.open(map, markers.B);
        map.setCenter(p.geometry.location);
        toggleSearchBtn();
      });
    }

    function toggleSearchBtn() {
      const a = document.getElementById('pointA').value.trim();
      const b = document.getElementById('pointB').value.trim();
      document.getElementById('searchBtn').disabled = !(a && b);
    }

    async function fetchRouteNames() {
      const res = await fetch(apiBase);
      const data = await res.json();
      const sel = document.getElementById('routeSelect');
      sel.innerHTML = '<option>è«‹é¸æ“‡è·¯ç·š</option>' + data.routes.map(n => `<option value="${n}">${n}</option>`).join('');
      sel.addEventListener('change', () => fetchRouteByName(sel.value));
    }

    async function fetchRouteByName(name) {
      clearMapObjects(); stationData = []; stationMarkersMini.forEach(m => m.setMap(null)); stationMarkersMini=[];
      const res = await fetch(`${apiBase}?routeName=${encodeURIComponent(name)}`);
      const d = await res.json();
      const list = document.getElementById('pointList'); list.innerHTML = '';
      d.points.forEach((p, i) => {
        stationData.push({ position:{lat:p.lat,lng:p.lng}, name: p.name });
        const row = document.createElement('div'); row.className='checkbox-row';
        row.innerHTML = `<input type="checkbox" id="pt${i}"><label for="pt${i}">ç¬¬${p.order}ç«™ ${p.name}</label>`;
        const cb = row.querySelector('input');
        cb.addEventListener('change', () => {
          if(cb.checked){
            const m = new google.maps.Marker({ map, position: {lat:p.lat,lng:p.lng} });
            m.addListener('click', () => { infoWindow.setContent(p.name); infoWindow.open(map,m); });
            markers[i] = m;
            map.setCenter(m.getPosition());
          } else if(markers[i]) markers[i].setMap(null);
        });
        list.appendChild(row);
      });
    }

    function drawPolylinePath(path) { 
      if(polyline) polyline.setMap(null); 
      polyline=new google.maps.Polyline({ path, map, strokeColor:'#FF5722', strokeWeight:4 }); 
    }

    function clearMapObjects() { 
      markers.forEach(m=>m&&m.setMap(null)); 
      markers=[]; 
      if(polyline) polyline.setMap(null); 
    }

    function resamplePath(path, interval) { 
      if(path.length<2) return path; 
      const result=[path[0]]; 
      let acc=0; 
      for(let i=1;i<path.length;i++){ 
        const p0=path[i-1], p1=path[i]; 
        const segLen=google.maps.geometry.spherical.computeDistanceBetween(p0,p1); 
        let dist=interval-acc; 
        while(dist<segLen){ 
          const frac=dist/segLen; 
          result.push(google.maps.geometry.spherical.interpolate(p0,p1,frac)); 
          dist+=interval; 
        } 
        acc=(acc+segLen)%interval; 
        result.push(p1);
      } 
      return result; 
    }

    function planPolyline(){
      stationMarkersMini.forEach(m=>m.setMap(null)); stationMarkersMini=[]; 
      const pts=stationData.filter((s,i)=>document.getElementById('pt'+i).checked).map(s=>s.position); 
      if(pts.length<2){ alert('è«‹è‡³å°‘é¸æ“‡å…©å€‹ç«™é»'); return; } 
      new google.maps.DirectionsService().route({ origin:pts[0], destination:pts.at(-1), waypoints:pts.slice(1,-1).map(p=>({location:p})), travelMode:'BICYCLING' }, (res,status) => { 
        if(status==='OK'){ 
          polylinePath=resamplePath(res.routes[0].overview_path,RESAMPLE_INTERVAL); 
          drawPolylinePath(polylinePath); 
          miniPolyline.setPath(polylinePath); 
          stationData.forEach((s,i)=>{ 
            if(document.getElementById('pt'+i).checked){ 
              const mm=new google.maps.Marker({ map:miniMap, position:s.position, title:s.name, label:{text:s.name, color:'black', fontSize:'10px'} }); 
              stationMarkersMini.push(mm);
            } 
          }); 
          document.getElementById('toggleViewBtn').style.display='inline-block';
          document.getElementById('autoPlayBtn').style.display='none';

          createMiniMapClickableMarkers();
          fetchElevationAndDrawChart(polylinePath);

        } else alert('è·¯ç·šç¹ªè£½å¤±æ•—:'+status); 
      });
    }

    function selectAll(){ 
      document.querySelectorAll('#pointList input[type=checkbox]').forEach(cb=>{cb.checked=true;cb.dispatchEvent(new Event('change'));}); 
    }
    function clearAll(){ 
      document.querySelectorAll('#pointList input[type=checkbox]').forEach(cb=>{cb.checked=false;cb.dispatchEvent(new Event('change'));}); 
    }

    async function drawFromPasted(){
      stationMarkersMini.forEach(m=>m.setMap(null)); stationMarkersMini=[]; clearMapObjects(); 
      const raw=document.getElementById('coordTextarea').value.trim(); 
      const lines=raw.split('\n').filter(l=>l.trim()); 
      const coords=lines.map(l=>{ 
        const m=l.match(/([\d\.\-]+)[^\d\.\-]+([\d\.\-]+)/); 
        return m?{lat:+m[1],lng:+m[2]}:null; 
      }).filter(c=>c); 
      if(coords.length<2){alert('è«‹è‡³å°‘æä¾›å…©å€‹åº§æ¨™');return;} 
      coords.forEach((c,i)=>{ 
        const mk=new google.maps.Marker({map,position:c}); 
        mk.addListener('click',()=>{infoWindow.setContent('æ‰‹å‹•é»#'+(i+1));infoWindow.open(map,mk);}); 
        markers.push(mk); 
      }); 
      new google.maps.DirectionsService().route({ origin:coords[0], destination:coords.at(-1), waypoints:coords.slice(1,-1).map(c=>({location:c})), travelMode:'BICYCLING' }, (res,status)=>{ 
        if(status==='OK'){ 
          polylinePath=resamplePath(res.routes[0].overview_path,RESAMPLE_INTERVAL); 
          drawPolylinePath(polylinePath); 
          miniPolyline.setPath(polylinePath); 
          document.getElementById('toggleViewBtn').style.display='inline-block';
          document.getElementById('autoPlayBtn').style.display='none';

          createMiniMapClickableMarkers();
          fetchElevationAndDrawChart(polylinePath);

        } else alert('è·¯ç·šè¦åŠƒå¤±æ•—:'+status); 
      });
    }

    function drawFromAB(){
      stationMarkersMini.forEach(m=>m.setMap(null)); stationMarkersMini=[]; clearMapObjects(); 
      new google.maps.DirectionsService().route({ origin:document.getElementById('pointA').value, destination:document.getElementById('pointB').value, travelMode:'BICYCLING' }, (res,status)=>{ 
        if(status==='OK'){ 
          polylinePath=resamplePath(res.routes[0].overview_path,RESAMPLE_INTERVAL); 
          drawPolylinePath(polylinePath); 
          miniPolyline.setPath(polylinePath); 
          document.getElementById('toggleViewBtn').style.display='inline-block';
          document.getElementById('autoPlayBtn').style.display='none';

          createMiniMapClickableMarkers();
          fetchElevationAndDrawChart(polylinePath);

        } else alert('æœå°‹å¤±æ•—:'+status); 
      });
    }

    function toggleView(){
      const autoBtn = document.getElementById('autoPlayBtn');
      if(currentMode==='map'){
        document.getElementById('map').style.display='none';
        document.getElementById('pano').style.display='block';
        document.getElementById('miniMap').style.display='block';
        panorama.setVisible(true);
        panorama.setPosition(polylinePath[0]);
        updateMiniMap();
        currentMode='street';
        autoBtn.style.display = 'inline-block';
      } else {
        document.getElementById('pano').style.display='none';
        document.getElementById('miniMap').style.display='none';
        document.getElementById('map').style.display='block';
        panorama.setVisible(false);
        currentMode='map';
        autoBtn.style.display = 'none';
        if (autoPlayTimer) {
          clearInterval(autoPlayTimer);
          autoPlayTimer = null;
          autoBtn.textContent = 'é–‹å§‹è‡ªå‹•å°èˆª';
        }
      }
    }

    function handleKey(e){ 
      if(currentMode!=='street'||!polylinePath.length) return; 
      if(e.key==='ArrowUp'||e.key.toLowerCase()==='w') moveAlongPath(1); 
      if(e.key==='ArrowDown'||e.key.toLowerCase()==='s') moveAlongPath(-1); 
      if(e.key.toLowerCase()==='a') panorama.setPov({...panorama.getPov(),heading:panorama.getPov().heading-15}); 
      if(e.key.toLowerCase()==='d') panorama.setPov({...panorama.getPov(),heading:panorama.getPov().heading+15}); 
      updateMiniMap(); 
    }

    function moveAlongPath(step){
      const old=stepIndex;
      stepIndex=Math.min(Math.max(0,stepIndex+step),polylinePath.length-1);
      const p0=polylinePath[old], p1=polylinePath[stepIndex];
      if(p0&&p1){
        const hd=google.maps.geometry.spherical.computeHeading(p0,p1);
        panorama.setPov({heading:hd,pitch:panorama.getPov().pitch});
      }
      panorama.setPosition(polylinePath[stepIndex]);
      updateMiniMap();
      updateElevationCursor();
    }

    function updateMiniMap(){
      const pos=panorama.getPosition();
      miniMap.setCenter(pos);
      miniMap.setHeading(panorama.getPov().heading||0);
      miniMarker.setPosition(pos);
      miniMarker.setIcon({ path:google.maps.SymbolPath.FORWARD_CLOSED_ARROW, scale:5, rotation:panorama.getPov().heading||0 });
      miniPolyline.setPath(polylinePath);
    }

    function startAutoPlay(){
      const btn=document.getElementById('autoPlayBtn');
      if(autoPlayTimer){
        clearInterval(autoPlayTimer); autoPlayTimer=null; btn.textContent='é–‹å§‹è‡ªå‹•å°èˆª';
      } else {
        btn.textContent='åœæ­¢è‡ªå‹•å°èˆª';
        autoPlayTimer=setInterval(()=>{
          if(stepIndex<polylinePath.length-1){
            moveAlongPath(1);
          } else startAutoPlay();
        }, 1000);
      }
    }

    function createMiniMapClickableMarkers() {
      miniMapMarkers.forEach(m => m.setMap(null));
      miniMapMarkers = [];

      polylinePath.forEach((pos, idx) => {
        const marker = new google.maps.Marker({
          position: pos,
          map: miniMap,
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 4,
            fillColor: '#4285F4',
            fillOpacity: 0.8,
            strokeWeight: 1,
            strokeColor: '#ffffff',
          },
          title: `å°èˆªé» #${idx + 1}`
        });

        marker.addListener('click', () => {
          panorama.setPosition(marker.getPosition());
          panorama.setPov({ heading: 0, pitch: 0 });
          panorama.setVisible(true);

          currentMode = 'street';
          document.getElementById('map').style.display = 'none';
          document.getElementById('pano').style.display = 'block';
          document.getElementById('miniMap').style.display = 'block';
          document.getElementById('autoPlayBtn').style.display = 'inline-block';
          document.getElementById('toggleViewBtn').style.display = 'inline-block';

          updateMiniMap();

          stepIndex = idx;
          updateElevationCursor();
        });

        miniMapMarkers.push(marker);
      });
    }

    function fetchElevationAndDrawChart(path) {
      if (!path || path.length === 0) return;

      const elevator = new google.maps.ElevationService();

      elevator.getElevationAlongPath({
        path: path,
        samples: 256
      }).then(response => {
        const results = response.results;
        elevationData = results.map(r => r.elevation);
        elevationLabels = results.map((_, i) => (i * (getPathLength(path) / results.length)).toFixed(0));

        drawElevationChart();
      }).catch(e => {
        console.error('Elevation API error:', e);
      });
    }

    function getPathLength(path) {
      let total = 0;
      for (let i = 1; i < path.length; i++) {
        total += google.maps.geometry.spherical.computeDistanceBetween(path[i-1], path[i]);
      }
      return total;
    }

    function drawElevationChart() {
      const ctx = document.getElementById('elevationChart').getContext('2d');

      if (elevationChart) {
        elevationChart.destroy();
      }

      elevationChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: elevationLabels,
          datasets: [{
            label: 'è·¯ç·šå¡åº¦ (å…¬å°º)',
            data: elevationData,
            borderColor: '#FF5722',
            backgroundColor: 'rgba(255,87,34,0.2)',
            fill: true,
            pointRadius: 0,
            borderWidth: 2,
            tension: 0.3
          }]
        },
        options: {
          responsive: true,
          scales: {
            x: {
              display: true,
              title: { display: true, text: 'è·é›¢ (å…¬å°º)' }
            },
            y: {
              display: true,
              title: { display: true, text: 'é«˜åº¦ (å…¬å°º)' }
            }
          },
          plugins: {
            legend: { display: false },
            tooltip: { enabled: false }
          },
          animation: false
        },
        plugins: [elevationCursorPlugin]
      });
    }

    const elevationCursorPlugin = {
      id: 'cursorLine',
      beforeDraw(chart) {
        if (!elevationChart || elevationCursorIndex < 0 || elevationCursorIndex >= elevationData.length) return;
        const { ctx, chartArea: { top, bottom }, scales: { x } } = chart;
        const xPos = x.getPixelForValue(elevationCursorIndex);
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(xPos, top);
        ctx.lineTo(xPos, bottom);
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'red';
        ctx.stroke();
        ctx.restore();
      }
    };

    function updateElevationCursor() {
      if (!elevationChart || !polylinePath.length) return;

      let distanceSoFar = 0;
      for (let i = 1; i <= stepIndex && i < polylinePath.length; i++) {
        distanceSoFar += google.maps.geometry.spherical.computeDistanceBetween(polylinePath[i-1], polylinePath[i]);
      }
      const totalDistance = getPathLength(polylinePath);
      const percent = distanceSoFar / totalDistance;

      elevationCursorIndex = Math.min(Math.floor(percent * elevationData.length), elevationData.length - 1);
      elevationChart.update();
    }
  </script>
</body>
</html>
